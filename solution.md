Алгоритм K-Tetris (потому что задачи размещаются на станки похоже на полимино в тетрисе).

Положим `C := количество классов`.
- Делим заказ на группы размера по `<= k`.
- Сортируем группы по приоритету `(deadline)` или `(deadline, amount * average time)`.
- Для каждого оборудования храним 2 величины: первое время, когда оборудование свободно `e.avaliable_to_start` (монотонно возрастает по ходу алгоритма), время выполнения 1 задачи на станке `e.work_time`.
- Храним `C` очередей содержащих `equipment e` с приоритетом по ключу `min(e.avaliable_to_start + k * e.work_time)` (минимум из ).
- Для каждой группы выбираем вершину минимальное по ключу оборудование `e` из всех очередей: i.e. выбираем станок, который может закончить работу быстрее всех, доступных сейчас.
- Отправляем группу на выполнение на оборудовании `e`. Возвращаем `e` в очередь, изменяя `e.avaliable_to_start += group.size * e.work_time.
- В алгоритм можно добавить данные модели об износе оборудования и изменить ключ в очереди с приоритетом так, чтобы он учитывал возможность поломки при выборе исполнителя.


`e := кол-во оборудования`, `p := количество зказов`, `a := среднее количество продукта в заказе`, `C := количество классов оборудования`, `k := параметр из алгоритма`.
Тогда сложность алгоритма $$O(\frac{p С a \log e}{k})$$
